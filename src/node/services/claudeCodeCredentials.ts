/**
 * Claude Code CLI Credential Reader
 *
 * Reads OAuth tokens from Claude Code CLI's storage to enable
 * using a Claude Max/Pro subscription for model access.
 *
 * Token sources (checked in order):
 * 1. CLAUDE_CODE_OAUTH_TOKEN env var (for CI/headless)
 * 2. macOS Keychain (service: "Claude Code-credentials")
 * 3. ~/.claude/.credentials.json file
 *
 * Tokens are generated by running `claude setup-token` in Claude Code CLI.
 *
 * Based on OpenClaw's cli-credentials.ts pattern.
 */

import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { log } from "./log";

// ── Constants ────────────────────────────────────────────────────────

const CLAUDE_CLI_KEYCHAIN_SERVICE = "Claude Code-credentials";
const CLAUDE_CLI_CREDENTIALS_PATH = ".claude/.credentials.json";

// ── Types ────────────────────────────────────────────────────────────

export type ClaudeCodeCredential =
  | {
      type: "oauth";
      accessToken: string;
      refreshToken: string;
      expiresAt: number;
    }
  | {
      type: "token";
      accessToken: string;
      expiresAt: number;
    };

// ── Cache ────────────────────────────────────────────────────────────

let cachedCredential: { value: ClaudeCodeCredential | null; readAt: number } | null = null;
const CACHE_TTL_MS = 30_000; // 30 seconds

// ── Public API ───────────────────────────────────────────────────────

/**
 * Read Claude Code CLI credentials with caching.
 * Returns null if no credentials found.
 */
export function getClaudeCodeCredentials(): ClaudeCodeCredential | null {
  const now = Date.now();
  if (cachedCredential && now - cachedCredential.readAt < CACHE_TTL_MS) {
    return cachedCredential.value;
  }

  const value = readClaudeCodeCredentials();
  cachedCredential = { value, readAt: now };
  return value;
}

/**
 * Get just the access token string, or null if unavailable.
 * This is the primary method used by aiService.
 */
export function getClaudeCodeAccessToken(): string | null {
  const cred = getClaudeCodeCredentials();
  if (!cred) return null;

  // Check if token is expired (with 60s buffer)
  if (cred.expiresAt > 0 && Date.now() > cred.expiresAt - 60_000) {
    log.warn("[ClaudeCodeCredentials] Token expired", {
      expiresAt: new Date(cred.expiresAt).toISOString(),
    });
    // Clear cache so next call re-reads from source
    cachedCredential = null;
    return null;
  }

  return cred.accessToken;
}

/**
 * Check if Claude Code CLI credentials are available and not expired.
 */
export function hasClaudeCodeCredentials(): boolean {
  return getClaudeCodeAccessToken() !== null;
}

/**
 * Check if a token is an OAuth token (sk-ant-oat*) that needs Authorization: Bearer header,
 * vs a regular API key (sk-ant-api*) that uses x-api-key header.
 */
export function isOAuthToken(token: string): boolean {
  return token.startsWith("sk-ant-oat");
}

/**
 * Clear the credential cache (useful for testing or after token refresh).
 */
export function clearClaudeCodeCredentialCache(): void {
  cachedCredential = null;
}

// ── Internal: Read from all sources ──────────────────────────────────

function readClaudeCodeCredentials(): ClaudeCodeCredential | null {
  // Source 1: Environment variable (highest priority, for CI/headless)
  const envToken = process.env.CLAUDE_CODE_OAUTH_TOKEN?.trim();
  if (envToken) {
    log.info("[ClaudeCodeCredentials] Using token from CLAUDE_CODE_OAUTH_TOKEN env var");
    return {
      type: "token",
      accessToken: envToken,
      // Env tokens don't have expiry info — treat as valid for 24h
      expiresAt: Date.now() + 24 * 60 * 60 * 1000,
    };
  }

  // Source 2: macOS Keychain
  if (process.platform === "darwin") {
    const keychainCred = readFromKeychain();
    if (keychainCred) {
      log.info("[ClaudeCodeCredentials] Read credentials from macOS Keychain", {
        type: keychainCred.type,
      });
      return keychainCred;
    }
  }

  // Source 3: Credentials file (~/.claude/.credentials.json)
  const fileCred = readFromCredentialsFile();
  if (fileCred) {
    log.info("[ClaudeCodeCredentials] Read credentials from ~/.claude/.credentials.json", {
      type: fileCred.type,
    });
    return fileCred;
  }

  return null;
}

// ── Internal: macOS Keychain ─────────────────────────────────────────

function readFromKeychain(): ClaudeCodeCredential | null {
  try {
    const raw = execSync(
      `security find-generic-password -s "${CLAUDE_CLI_KEYCHAIN_SERVICE}" -w`,
      { encoding: "utf8", timeout: 5000, stdio: ["pipe", "pipe", "pipe"] },
    ).trim();

    const data = JSON.parse(raw) as Record<string, unknown>;
    const claudeOauth = data?.claudeAiOauth as Record<string, unknown> | undefined;
    if (!claudeOauth || typeof claudeOauth !== "object") {
      return null;
    }

    const accessToken = claudeOauth.accessToken;
    const refreshToken = claudeOauth.refreshToken;
    const expiresAt = claudeOauth.expiresAt;

    if (typeof accessToken !== "string" || !accessToken) {
      return null;
    }
    if (typeof expiresAt !== "number" || expiresAt <= 0) {
      return null;
    }

    if (typeof refreshToken === "string" && refreshToken) {
      return {
        type: "oauth",
        accessToken,
        refreshToken,
        expiresAt,
      };
    }

    return {
      type: "token",
      accessToken,
      expiresAt,
    };
  } catch {
    // Keychain entry not found or access denied — fall through
    return null;
  }
}

// ── Internal: Credentials file ───────────────────────────────────────

function readFromCredentialsFile(): ClaudeCodeCredential | null {
  try {
    const homeDir = process.env.HOME ?? process.env.USERPROFILE ?? "";
    const credPath = path.join(homeDir, CLAUDE_CLI_CREDENTIALS_PATH);

    if (!fs.existsSync(credPath)) {
      return null;
    }

    const raw = fs.readFileSync(credPath, "utf8");
    const data = JSON.parse(raw) as Record<string, unknown>;
    const claudeOauth = data?.claudeAiOauth as Record<string, unknown> | undefined;
    if (!claudeOauth || typeof claudeOauth !== "object") {
      return null;
    }

    const accessToken = claudeOauth.accessToken;
    const refreshToken = claudeOauth.refreshToken;
    const expiresAt = claudeOauth.expiresAt;

    if (typeof accessToken !== "string" || !accessToken) {
      return null;
    }
    if (typeof expiresAt !== "number" || expiresAt <= 0) {
      return null;
    }

    if (typeof refreshToken === "string" && refreshToken) {
      return {
        type: "oauth",
        accessToken,
        refreshToken,
        expiresAt,
      };
    }

    return {
      type: "token",
      accessToken,
      expiresAt,
    };
  } catch {
    return null;
  }
}
